<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Flood - Help</title>
  </head>
  <body>
    <h2 id="table-of-contents">Table of Contents</h2>
    <ol>
      <li>
        <a href="#basic-actions">Basic Actions</a>
      </li>
      <li>
        <a href="#speed-modifiers">Speed Modifiers</a>
      </li>
      <li>
        <a href="#basic-actions">Neighbor Enumeration Strategies</a>
        <ul>
          <li>
            <a href="#uniform">Uniform</a>
          </li>
          <li>
            <a href="#random-per-fill">Random per fill</a>
          </li>
          <li>
            <a href="#random-each-time">Random always</a>
          </li>
          <li>
            <a href="#random-per-pixel">Random per pixel</a>
          </li>
        </ul>
      </li>
    </ol>
    <hr/>
    <h2 id="introduction">Flood-Fill Visualization</h2>
    <p>
      A flood fill is a sparse-graph traversal in which both adjacency and
      visitation information is implicit in the image being read and written.
      When a flood fill is performed atomically (no other changes to the image
      while the fill is happening), all variations produce the same results.
      But the order in which pixels are found and filled depends on:
    </p>
    <ul>
      <li>
        The data structure used for the <em>fringe</em>, i.e., the vertices
        (pixel locations) that have been discovered but are not yet filled.
        This is most often a stack (last-in, first-out) or "queue" (first-in,
        first-out), but any kind of generalized queue will work. See
        <a href="#basic-actions">Basic Actions</a>.
      </li>
      <li>
        The order in which neighboring verties (pixel locations) that may need
        to be filled are checked and added to the fringe. This is especially
        significant when a stack is used for the fringe, because with a stack,
        many steps often progress between when a vertex (pixel location) is
        added to the fringe and when it is actually filled. See
        <a href="#basic-actions">Neighbor Enumeration Strategies</a>.
      </li>
    </ul>
    <p>
      This is an early version, perhaps even a prototype for a different design.
      Fill type and configuration can only be speified through shortcuts, not
      menus. Besides fixing that, other accessibility improvements should be
      made: at minimum, it should be no harder to use without a mouse (or
      limited mousing) than popular raster graphics editors. This also only
      runs on Windows, which is not ideal.
    </p>
    <h2 id="basic-actions">Basic Actions</h2>
    <!-- TODO: Add expanded explanations, converting to paragraphs. -->
    <ul>
      <li>
        Left-click and drag to draw on the canvas.
      </li>
      <li>
        Right-click to flood-fill with a stack (a LIFO queue).
      </li>
      <li>
        Middle-click to flood-fill with a "queue" (i.e., a FIFO queue).
      </li>
      <li>
        <kbd>Alt</kbd> + right-click to flood-fill with a random extraction
        queue. Extraction selects any element with equal probability.
      </li>
      <li>
        <kbd>Alt</kbd> + middle-click to flood-fill with a deque. Extraction
        randomly selects the front or back with equal probability.
      </li>
    </ul>
    <h2 id="speed-modifiers">Speed Modifiers</h2>
    <p>
      By default, fills proceeed at a rate of 5 pixels per frame. You can
      override that by pressing:
    </p>
    <ul>
      <li>
        <kbd>Shift</kbd> to fill slowly (1 pixel per frame).
      </li>
      <li>
        <kbd>Ctrl</kbd> to fill very fast (20 pixels per frame).
      </li>
      <li>
        <kbd>Ctrl</kbd>+<kbd>Shift</kbd> to fill pretty fast (10 pixels per
        frame).
      </li>
    </ul>
    <p>
      Modifiers affect the speed of <strong>newly started fills</strong>. That
      way, you can have concurrent fills proceeding at different speeds.
    </p>
    <h2 id="neighbor-enumeration-strategies">
      Neighbor Enumeration Strategies
    </h2>
    <p>
      There are several major strategies for the order in which neighbors are
      enumerated, and some (currently, just one) are configurable by the
      selection of sub-strategies.
    </p>
    <p>
      Use the scroll-wheel (with no modifier keys) to cycle between major
      neighbor-enumeration strategies.
    </p>
    <p>
      Hold down <kbd>Shift</kbd> while using the scroll-wheel to cycle between
      sub-strategies for the currently selected major strategy.
    </p>
    <p>
      <strong>The mouse pointer must be over the canvas when
      scrolling.</strong> This is to avoid accidentally changing the neighbor
      enumeration strategy when attempting to scroll something else.
    </p>
    <p>
      The available neighbor enumeration strategies (with their sub-strategies)
      are:
    </p>
    <h3 id="uniform">Uniform</h3>
    <p>
      Neighbors are always enumerated in the same order. The sub-strategy
      determines which order that is. There are 24 sub-strategies, since that's
      how many permutations of Left, Right, Up, and Down there are.
      Substrategies are abbreviated by the first letters of each direction, in
      the order in which neighbors are enumerated. The default sub-strategy is
      <strong>LRUD</strong>.
    </p>
    <h3 id="random-per-fill">Random per fill</h3>
    <p>
      Neighbors are enumerated in an order that is uniform in each fill, but
      different&mdash;and randomly chosen&mdash;each time a fill is peformed.
      This is thus the same as using the <a href="#uniform">Uniform</a>
      strategy an choosing a random sub-strategy immediately before every fill.
    </p>
    <h3 id="random-each-time">Random always</h3>
    <p>
      Each time neighbors are enumerated, even within the same fill, the order
      is randomly selected. If the same pixel is reached multiple times, even
      in the same fill (which is possible in the case of concurrent
      <em>physically nested</em> fills interfering with each other), a
      different order may be chosen.
    </p>
    <h3 id="random-per-pixel">Random per pixel</h3>
    <p>
      Each pixel in the image has an order in which neighbors are always
      enumerated, and each order is randomly determined separately. If the same
      pixel is reached multiple times, even in separate fills (whether or not
      they overlap in time), the same order is chosen for each pixel.
      Restarting the program generates a different order. Without looking
      closely, you won't notice the difference between this and
      <a href="#random-each-time">Random always</a>.
    </p>
  </body>
</html>
